# -*- coding: cp1251 -*-
def calc_sads(mas):
    #сумма элементов в выборке
    sum = 0
    #среднее выборочное
    avr = 0
    #дисперсия (среднеквадратичное отклонение)
    D = 0
    #стандартное отклонение (корень из дисперсии)
    sd = 0
    #доверительный 95% интервал
    ti = [0, 0]

    for element in mas:
        sum += element
    avr = sum / len(mas)
    for element in mas:
        D += ((avr - element) ** 2) / (len(mas) - 1)
    sd = D ** (0.5)
    se = sd / (len(mas) ** (0.5))
    ti = [avr - (1.96 * se), avr + (1.96 * se)]

    print("DATA: ", mas)
    print(" summ: {0:3}\n average: {1:3}\n standart_deviation: {2:3}\n standart_error: {3:3}".format(sum, avr, sd, se))
    print(" trusted_interval: ", ti)

    print("\n")

def calc_t(x, u, sd, n):
    # x-выборочное среднее
    # u-среднее в генеральной совокупности
    # n-размер выборки
    # sd-стандартное отклонение
    # t-нормализованное отклонение среднего выборочного от среднего в генеральной (в единицах сигмы, x=0, sd=1)
    se = sd/(n**(0.5))
    t = ((x-u)/se)
    return t

def calc_tcrit(x1,sd1,n1,x2,sd2,n2):
    #критерий т-стьюдента показывает является ли разница средних двух разных выборок статистически значимой
    #x1 - среднее в первой выборке, sd1 - отклонение в первой выборке, n1 - размер первой выборки
    #то же самое для второй. используем функцию похожую на calc_t только отклонение считаем по-другому
    #это всё нужно чтобы понять, принадлижат ли выборки M1 и M2 к одной и той же генеральной совокупности
    x = x1
    u = x2
    se = ((sd1**2)/n1 + (sd2**2)/n2)**(0.5)
    #df-степени свобод
    df = n1+n2-2
    t = ((x-u)/se)
    print(" t: {0:3}\n df: {1:3}\n".format(t, df))

mas1 = [1, 5, 2, 7, 1, 9, 3, 8, 5, 9]
mas2 = [1, 5, 2, 7, 1, 9, 3, 8, 5, 9, 1, 5, 2, 7, 1, 9, 6, 8, 9, 9]
#calc_sads(mas1)
#calc_sads(mas2)
calc_tcrit(45,9,100,34,10,100)
#
# false_alarm1 <- function(m, n, a) {
#   # Создаем пустой дата фрейм с n наблюдениями (строками) и m выборками (столбцами)
#   d <- data.frame(matrix(0, n, m))
#   # Создаем матрицу возможных сочетаний переменных для будущего т-теста
#   s <- combn(1:m, 2)
#   # Создаем ветор с длинной 1000 для последующей записи 1000 извлечений выборок
#   x <- vector("numeric", 1000)
#
#   # Создаем собственную упрощенную версию т.теста, которая возвращает только
#   # p.value (значительно ускоряет всю функцию)
#   t_test_pval <- function(x, y) {
#     se <- sqrt((var(x) + var(y))/n)
#     t_stat <- (mean(x) - mean(y))/se
#     df <- n + n - 2
#     pval <- 2*pt(abs(t_stat), df, lower.tail = F)
#     pval
#   }
#
#   for (q in 1:1000) {
#     d <- data.frame(apply(d, 2, function(i) rnorm(n)))
#     # Заполняем пустой дата фрейм случайными выборками,
#     # т.е. извлекаем из г.с. m-выборок
#     for (i in 1:ncol(s)) {
#       TEST <- t_test_pval(d[, s[1, i]], d[, s[2, i]])
#       if(TEST < a) x[q] <- 1
#       if(TEST < a) break
#     }
#   }
#   x <- as.data.frame(table(x))
#   barplot(x$Freq, names.arg = c("Нет", "Да"),
#           col = c("Red", "Blue"),
#           main = x$Freq[2]/1000*100,
#           ylab = "Количество",
#           xlab = "Значимые различия",
#           ylim = c(0,1000))
# }